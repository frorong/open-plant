<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>API Reference | Open Plant WSI Docs</title>
    <meta name="description" content="Open Plant WSI API 레퍼런스" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:wght@400;500;600;700;800&family=IBM+Plex+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../assets/site.css" />
  </head>
  <body data-page="api-reference">
    <header class="topbar">
      <div class="topbar-inner">
        <a class="brand" href="index.html"><span class="brand-dot"></span><span>Open Plant WSI</span></a>
        <nav class="topnav" aria-label="Main Navigation">
          <a href="index.html" data-nav="index">개요</a>
          <a href="getting-started.html" data-nav="getting-started">빠른 시작</a>
          <a href="draw-and-roi.html" data-nav="draw-and-roi">ROI 그리기</a>
          <a href="api-reference.html" data-nav="api-reference">API</a>
          <a href="migration-guide.html" data-nav="migration-guide">마이그레이션</a>
          <a href="contributing.html" data-nav="contributing">기여 가이드</a>
          <a href="architecture.html" data-nav="architecture">아키텍처</a>
          <a href="deploy-github-pages.html" data-nav="deploy-github-pages">배포</a>
          <a href="../en/api-reference.html">EN</a>
        </nav>
      </div>
    </header>

    <main class="page">
      <div class="layout">
        <aside class="sidebar">
          <h2>API</h2>
          <a href="#wsi-viewer">WsiViewerCanvas</a>
          <a href="#draw-layer">DrawLayer</a>
          <a href="#tile-viewer">TileViewerCanvas</a>
          <a href="#wsi-types">WSI 타입</a>
          <a href="#utils">유틸 함수</a>
          <a href="#api-stability">API 안정성</a>
          <a href="migration-guide.html">마이그레이션 가이드</a>
        </aside>

        <article class="content">
          <section class="hero reveal">
            <div class="kicker">Reference</div>
            <h1>공개 API 레퍼런스</h1>
            <p>
              아래 표는 `src/index.ts`에서 export된 항목 기준입니다.
              타입/시그니처가 변경되면 이 문서도 함께 업데이트하세요.
            </p>
          </section>

          <section class="panel reveal" id="wsi-viewer">
            <h2>`WsiViewerCanvas` Props</h2>
            <table>
              <thead>
                <tr><th>이름</th><th>타입</th><th>설명</th></tr>
              </thead>
              <tbody>
                <tr><td><code>source</code></td><td><code>WsiImageSource | null</code></td><td>렌더 대상 이미지 메타데이터.</td></tr>
                <tr><td><code>authToken</code></td><td><code>string</code></td><td>필요한 요청에 Authorization 헤더 토큰을 주입합니다.</td></tr>
                <tr><td><code>viewState</code></td><td><code>Partial&lt;WsiViewState&gt;</code></td><td>외부 제어 줌/오프셋/회전(<code>rotationDeg</code>) 상태.</td></tr>
                <tr><td><code>onViewStateChange</code></td><td><code>(next) =&gt; void</code></td><td>카메라 상태 변경 콜백.</td></tr>
                <tr><td><code>imageColorSettings</code></td><td><code>WsiImageColorSettings | null</code></td><td>타일 전용 밝기/대비/채도 입력(<code>[-100, 100]</code>). point/ROI/draw overlay에는 적용되지 않습니다.</td></tr>
                <tr><td><code>onStats</code></td><td><code>(stats: WsiRenderStats) =&gt; void</code></td><td>프레임 관측 이벤트. 타일/포인트 통계와 queue/failure/cache hit/miss, frame 시간 포함.</td></tr>
                <tr><td><code>onTileError</code></td><td><code>(event) =&gt; void</code></td><td>타일 로드 실패 콜백(타일 정보, 오류 객체, 재시도 횟수).</td></tr>
                <tr><td><code>onContextLost</code></td><td><code>() =&gt; void</code></td><td>WebGL 컨텍스트 손실 시 호출되며 렌더 루프가 일시 정지됩니다.</td></tr>
                <tr><td><code>onContextRestored</code></td><td><code>() =&gt; void</code></td><td>컨텍스트 복구 후 GPU 상태 재구성 완료 시 호출됩니다.</td></tr>
                <tr><td><code>debugOverlay</code></td><td><code>boolean</code></td><td>내장 런타임 디버그 HUD 표시. 기본값 <code>false</code>.</td></tr>
                <tr><td><code>debugOverlayStyle</code></td><td><code>CSSProperties</code></td><td>내장 디버그 HUD 스타일 오버라이드.</td></tr>
                <tr><td><code>fitNonce</code></td><td><code>number</code></td><td>값이 바뀌면 fit-to-image 재실행.</td></tr>
                <tr><td><code>rotationResetNonce</code></td><td><code>number</code></td><td>값이 바뀌면 회전을 0도로 리셋.</td></tr>
                <tr><td><code>ctrlDragRotate</code></td><td><code>boolean</code></td><td><code>Ctrl/Cmd + drag</code> 회전 허용. 기본값 <code>true</code>.</td></tr>
                <tr><td><code>minZoom</code></td><td><code>number</code></td><td>최소 줌 override. 미지정 시 <code>fitZoom * 0.5</code>. wheel/double-click/<code>setViewState</code>/<code>fitToImage</code> 경로 모두 적용.</td></tr>
                <tr><td><code>maxZoom</code></td><td><code>number</code></td><td>최대 줌 override. 미지정 시 <code>fitZoom * 8</code>.</td></tr>
                <tr><td><code>viewTransition</code></td><td><code>{ duration?: number; easing?: (t) =&gt; number }</code></td><td>기본 카메라 전환 애니메이션. duration은 <code>0..2000ms</code>로 clamp됩니다.</td></tr>
                <tr><td><code>pointData</code></td><td><code>WsiPointData | null</code></td><td>포인트 위치 + 팔레트 인덱스 버퍼(<code>ids</code>로 hit-test 지원).</td></tr>
                <tr><td><code>pointPalette</code></td><td><code>Uint8Array | null</code></td><td>RGBA palette texture 데이터.</td></tr>
                <tr><td><code>pointSizeByZoom</code></td><td><code>Record&lt;number, number&gt;</code></td><td>continuous zoom 기준 point 크기(px) stop. stop 사이는 선형 보간.</td></tr>
                <tr><td><code>pointStrokeScale</code></td><td><code>number</code></td><td>point ring 두께 스케일.</td></tr>
                <tr><td><code>roiRegions</code></td><td><code>WsiRegion[]</code></td><td>영속 ROI 목록(라벨 포함).</td></tr>
                <tr><td><code>roiPolygons</code></td><td><code>DrawCoordinate[][]</code></td><td>간소화 ROI 입력.</td></tr>
                <tr><td><code>clipPointsToRois</code></td><td><code>boolean</code></td><td>ROI 외부 포인트 제거.</td></tr>
                <tr><td><code>clipMode</code></td><td><code>"sync" | "worker" | "hybrid-webgpu"</code></td><td>ROI clip 실행 모드. 기본값 <code>"worker"</code>.</td></tr>
                <tr><td><code>onClipStats</code></td><td><code>(event) =&gt; void</code></td><td>clip 실행 통계 콜백(mode, duration, input/output, WebGPU 사용 여부, draw 브리지 여부 <code>bridgedToDraw</code>).</td></tr>
                <tr><td><code>onRoiPointGroups</code></td><td><code>(stats) =&gt; void</code></td><td>현재 포인트/ROI 기준 ROI별 term count 콜백.</td></tr>
                <tr><td><code>roiPaletteIndexToTermId</code></td><td><code>ReadonlyMap&lt;number,string&gt; | string[]</code></td><td>ROI term count 집계용 paletteIndex→termId 매핑.</td></tr>
                <tr><td><code>interactionLock</code></td><td><code>boolean</code></td><td>캔버스 pan/zoom 잠금.</td></tr>
                <tr><td><code>drawTool</code></td><td><code>"cursor" | "freehand" | "rectangle" | "circular" | "brush" | StampDrawTool</code></td><td>활성 draw 툴. <code>stamp-rectangle-4096px</code>는 patch intent, brush는 <code>intent: "brush"</code>를 emit합니다.</td></tr>
                <tr><td><code>stampOptions</code></td><td><code>{ rectangleAreaMm2?: number; circleAreaMm2?: number; rectanglePixelSize?: number }</code></td><td>외부에서 stamp 크기 제어. 기본값은 면적 stamp 2mm², 고정 사각형 4096px.</td></tr>
                <tr><td><code>brushOptions</code></td><td><code>BrushOptions</code></td><td>brush 반경/디테일/스무딩/커서 옵션. 반경은 HTML/CSS px 기준으로 화면에서 줌 불변입니다.</td></tr>
                <tr><td><code>drawFillColor</code></td><td><code>string</code></td><td>freehand/rectangle/circular draw preview fill 색상. 기본값 <code>transparent</code>.</td></tr>
                <tr><td><code>patchRegions</code></td><td><code>WsiRegion[]</code></td><td>ROI 상호작용과 분리된 patch 전용 영속 polygon 목록.</td></tr>
                <tr><td><code>patchStrokeStyle</code></td><td><code>Partial&lt;RegionStrokeStyle&gt;</code></td><td>patch 전용 stroke override(기본: cyan 점선).</td></tr>
                <tr><td><code>regionStrokeStyle</code></td><td><code>Partial&lt;RegionStrokeStyle&gt;</code></td><td>ROI stroke 스타일 override.</td></tr>
                <tr><td><code>regionStrokeHoverStyle</code></td><td><code>Partial&lt;RegionStrokeStyle&gt;</code></td><td>ROI hover 시 stroke 스타일 override.</td></tr>
                <tr><td><code>regionStrokeActiveStyle</code></td><td><code>Partial&lt;RegionStrokeStyle&gt;</code></td><td>ROI active 시 stroke 스타일 override (shadow 포함).</td></tr>
                <tr><td><code>resolveRegionStrokeStyle</code></td><td><code>(context) =&gt; Partial&lt;RegionStrokeStyle&gt;</code></td><td>region/state별 동적 stroke 스타일 resolver.</td></tr>
                <tr><td><code>resolveRegionLabelStyle</code></td><td><code>(context) =&gt; Partial&lt;RegionLabelStyle&gt;</code></td><td>region/zoom별 동적 라벨 스타일 resolver(<code>offsetY</code> 등).</td></tr>
                <tr><td><code>overlayShapes</code></td><td><code>DrawOverlayShape[]</code></td><td>DrawLayer 커스텀 오버레이 도형(폴리곤 stroke + 반전 마스크 지원).</td></tr>
                <tr><td><code>customLayers</code></td><td><code>WsiCustomLayer[]</code></td><td>world/screen 변환기를 받는 커스텀 React 오버레이 레이어 슬롯.</td></tr>
                <tr><td><code>regionLabelStyle</code></td><td><code>Partial&lt;RegionLabelStyle&gt;</code></td><td>영속 region 라벨 스타일 override.</td></tr>
                <tr><td><code>drawAreaTooltip</code></td><td><code>DrawAreaTooltipOptions</code></td><td>freehand/rectangle/circular draw 중 실시간 mm² tooltip.</td></tr>
                <tr><td><code>autoLiftRegionLabelAtMaxZoom</code></td><td><code>boolean</code></td><td><code>maxZoom</code> 도달 시 라벨을 20px 위로 애니메이션 이동하고, 이탈 시 복귀.</td></tr>
                <tr><td><code>onPointerWorldMove</code></td><td><code>(event) =&gt; void</code></td><td>월드 좌표 포인터 스트림 콜백.</td></tr>
                <tr><td><code>onPointHover</code></td><td><code>(event) =&gt; void</code></td><td>cursor 모드에서 nearest point hover 이벤트. 미히트 시 <code>index/id</code>는 <code>null</code>.</td></tr>
                <tr><td><code>onPointClick</code></td><td><code>(event) =&gt; void</code></td><td>cursor 모드에서 nearest point 클릭 이벤트(버튼 정보 포함).</td></tr>
                <tr><td><code>getCellByCoordinatesRef</code></td><td><code>MutableRefObject&lt;(coord) =&gt; PointHitEvent | null&gt;</code></td><td>월드 좌표 기반 point hit-test 함수를 imperative ref로 노출.</td></tr>
                <tr><td><code>onRegionHover</code></td><td><code>(event) =&gt; void</code></td><td>cursor 모드 region hover 이벤트.</td></tr>
                <tr><td><code>onRegionClick</code></td><td><code>(event) =&gt; void</code></td><td>cursor 모드 region 클릭 이벤트.</td></tr>
                <tr><td><code>activeRegionId</code></td><td><code>string | number | null</code></td><td>controlled active region id. 생략하면 uncontrolled 모드로 동작.</td></tr>
                <tr><td><code>onActiveRegionChange</code></td><td><code>(regionId) =&gt; void</code></td><td>active region 변경 이벤트. 기본 동작은 같은 region 재클릭 시 토글 해제, 빈 공간 클릭 시 해제입니다.</td></tr>
                <tr><td><code>onDrawComplete</code></td><td><code>(result) =&gt; void</code></td><td>도형 완료 콜백. payload에 <code>intent: "roi" | "patch" | "brush"</code> 포함.</td></tr>
                <tr><td><code>onPatchComplete</code></td><td><code>(result) =&gt; void</code></td><td><code>stamp-rectangle-4096px</code> 완료 시 patch 전용 콜백.</td></tr>
                <tr><td><code>overviewMapConfig</code></td><td><code>OverviewMapConfig</code></td><td>Overview map 표시/옵션/스타일.</td></tr>
                <tr><td><code>className</code></td><td><code>string</code></td><td>루트 컨테이너 className.</td></tr>
                <tr><td><code>style</code></td><td><code>CSSProperties</code></td><td>루트 컨테이너 style.</td></tr>
              </tbody>
            </table>
            <div class="callout">
              cursor 모드의 region hit-test는 contour + 라벨 영역만 대상으로 하며, 내부 fill 영역은 의도적으로 제외됩니다.
            </div>
            <div class="callout">
              타일 색상 보정 정규화: <code>brightness / 200</code>, <code>contrast / 100</code>, <code>saturation / 100</code>. 타일 셰이더에만 적용됩니다.
            </div>
          </section>

          <section class="panel reveal" id="draw-layer">
            <h2>`DrawLayer` / 도형 유틸</h2>
            <table>
              <thead>
                <tr><th>Export</th><th>설명</th></tr>
              </thead>
              <tbody>
                <tr><td><code>DrawLayer</code></td><td>독립 오버레이 캔버스 컴포넌트.</td></tr>
                <tr><td><code>closeRing(coords)</code></td><td>첫점/끝점을 닫아 polygon ring 생성.</td></tr>
                <tr><td><code>createRectangle(start, end)</code></td><td>사각형 폐곡선 좌표 생성.</td></tr>
                <tr><td><code>createCircle(start, end)</code></td><td>원형 다각형 좌표 생성.</td></tr>
                <tr><td><code>DrawResult</code></td><td><code>{ tool, intent, coordinates, bbox, areaPx }</code> (`intent`는 <code>"roi"</code>, <code>"patch"</code>, <code>"brush"</code>)</td></tr>
                <tr><td><code>PatchDrawResult</code></td><td><code>stamp-rectangle-4096px</code> 전용 patch 결과 타입.</td></tr>
                <tr><td><code>DrawRegion</code></td><td><code>{ id?, coordinates, label? }</code></td></tr>
                <tr><td><code>DrawIntent</code></td><td>draw 완료 intent 유니온(<code>"roi" | "patch" | "brush"</code>).</td></tr>
                <tr><td><code>DrawOverlayShape</code></td><td><code>{ id?, coordinates, closed?, fill?, stroke?, strokeStyle?, invertedFill?, visible? }</code> 형태의 오버레이 입력. <code>coordinates</code>는 <code>DrawCoordinate[]</code>, <code>DrawCoordinate[][]</code>, <code>DrawCoordinate[][][]</code>(single ring/multi-ring/multi-polygon)을 받습니다.</td></tr>
                <tr><td><code>DrawOverlayInvertedFillStyle</code></td><td><code>{ fillColor: string }</code> 폴리곤 바깥 영역을 채우는 반전 마스크 색상 스타일.</td></tr>
                <tr><td><code>BrushOptions</code></td><td>brush 반경/디테일/스무딩/커서 옵션. <code>radius</code>는 HTML/CSS px 기준(화면 고정)이며 결과 좌표는 줌에 맞게 world로 변환됩니다.</td></tr>
                <tr><td><code>RegionStyleContext</code></td><td><code>resolveRegionStrokeStyle</code>에 전달되는 상태 payload(<code>default</code>/<code>hover</code>/<code>active</code>).</td></tr>
                <tr><td><code>RegionLabelStyleContext</code></td><td>라벨 resolver context(<code>region</code>, <code>regionId</code>, <code>regionIndex</code>, <code>zoom</code>).</td></tr>
                <tr><td><code>RegionLabelStyleResolver</code></td><td><code>resolveRegionLabelStyle</code>에서 사용하는 동적 라벨 스타일 resolver.</td></tr>
                <tr><td><code>StampOptions</code></td><td>면적(mm²) + 고정 픽셀 사각형 옵션.</td></tr>
                <tr><td><code>RegionStrokeStyle</code></td><td>색상/두께/점선/캡/조인 + shadow(색상/블러/오프셋) 제어.</td></tr>
                <tr><td><code>RegionLabelStyle</code></td><td>폰트/배경/패딩/오프셋/라운드 제어.</td></tr>
                <tr><td><code>DrawAreaTooltipOptions</code></td><td>실시간 면적 tooltip 옵션(<code>enabled</code>, <code>format</code>, <code>style</code>, <code>cursorOffset</code>).</td></tr>
                <tr><td><code>DrawAreaTooltipStyle</code></td><td>draw 중 tooltip 글꼴/배경/패딩 스타일.</td></tr>
              </tbody>
            </table>
          </section>

          <section class="panel reveal" id="tile-viewer">
            <h2>`TileViewerCanvas` Props</h2>
            <table>
              <thead>
                <tr><th>이름</th><th>타입</th><th>설명</th></tr>
              </thead>
              <tbody>
                <tr><td><code>imageWidth</code></td><td><code>number</code></td><td>원본 너비(px).</td></tr>
                <tr><td><code>imageHeight</code></td><td><code>number</code></td><td>원본 높이(px).</td></tr>
                <tr><td><code>tiles</code></td><td><code>TileDefinition[]</code></td><td>M1 타일 정의 리스트.</td></tr>
                <tr><td><code>viewState</code></td><td><code>Partial&lt;ViewState&gt;</code></td><td>초기/외부 시점 제어.</td></tr>
              </tbody>
            </table>
          </section>

          <section class="panel reveal" id="wsi-types">
            <h2>핵심 타입</h2>
            <pre><code class="language-ts">interface WsiImageSource {
  id: string;
  name: string;
  width: number;
  height: number;
  mpp?: number;
  tileSize: number;
  maxTierZoom: number;
  tilePath: string;
  tileBaseUrl: string;
  terms: WsiTerm[];
  tileUrlBuilder?: (tier: number, x: number, y: number) => string;
}

interface WsiPointData {
  count: number;
  positions: Float32Array; // [x0,y0,x1,y1,...]
  paletteIndices: Uint16Array;
  fillModes?: Uint8Array; // point 채움 모드(0: ring, 1: solid)
  ids?: Uint32Array; // hit-test/cell 액션용 선택 ID
  drawIndices?: Uint32Array; // 선택 인덱스 브리지(선택적)
}

interface WsiViewState {
  zoom: number;
  offsetX: number;
  offsetY: number;
  rotationDeg: number;
}

interface WsiRenderStats {
  tier: number;
  visible: number;
  rendered: number;
  fallback: number;
  points: number;
  cache: number;
  inflight: number;
  queued?: number;
  retries?: number;
  failed?: number;
  aborted?: number;
  cacheHits?: number;
  cacheMisses?: number;
  drawCalls?: number;
  frameMs?: number;
}</code></pre>
          </section>

          <section class="panel reveal" id="api-stability">
            <h2>API 안정성 정책 (WS-10)</h2>
            <div class="flow">
              <div class="flow-step"><strong>SemVer:</strong> patch = 버그 수정, minor = 하위호환 기능 추가, major = 브레이킹 변경.</div>
              <div class="flow-step"><strong>Deprecation 수명주기:</strong> 대체 API를 먼저 제공하고 문서에서 deprecated 표시 후 최소 두 번의 minor 릴리스 동안 호환을 유지하며, 제거는 다음 major에서만 수행합니다.</div>
              <div class="flow-step"><strong>Migration 계약:</strong> 브레이킹 변경에는 before/after 예시와 체크리스트를 반드시 동반합니다.</div>
            </div>
            <div class="callout">
              Known limitations: 실제 브라우저 상호작용(pan/zoom/draw) E2E 자동화는 아직 CI에서 완전 커버되지 않습니다.
            </div>
            <div class="callout">
              실제 업그레이드 절차와 before/after 예시는 <a href="migration-guide.html">마이그레이션 가이드</a>를 확인하세요.
            </div>
          </section>

          <section class="panel reveal" id="utils">
            <h2>유틸 함수</h2>
            <table>
              <thead>
                <tr><th>함수</th><th>설명</th></tr>
              </thead>
              <tbody>
                <tr><td><code>normalizeImageInfo(raw, tileBaseUrl)</code></td><td>백엔드 응답 + 타일 베이스 URL을 `WsiImageSource`로 변환.</td></tr>
                <tr><td><code>toTileUrl(source, tier, x, y)</code></td><td>IMS 타일 URL 생성.</td></tr>
                <tr><td><code>buildTermPalette(terms)</code></td><td>termId → palette index 매핑 + RGBA 팔레트 생성.</td></tr>
                <tr><td><code>filterPointDataByPolygons(data, polygons)</code></td><td>ROI 다각형 기반 포인트 필터링.</td></tr>
                <tr><td><code>filterPointDataByPolygonsInWorker(data, polygons)</code></td><td>ROI 필터를 워커 스레드에서 실행합니다.</td></tr>
                <tr><td><code>terminateRoiClipWorker()</code></td><td>공유 ROI clip worker 인스턴스를 종료합니다(teardown/테스트에서 유용).</td></tr>
                <tr><td><code>filterPointIndicesByPolygons(data, polygons)</code></td><td>polygon 내부 원본 point 인덱스를 반환해 patch JSON export 파이프라인을 구성합니다.</td></tr>
                <tr><td><code>filterPointIndicesByPolygonsInWorker(data, polygons)</code></td><td>point 인덱스 반환의 워커 버전(+duration 메타).</td></tr>
                <tr><td><code>filterPointDataByPolygonsHybrid(data, polygons, options?)</code></td><td>실험적 하이브리드 경로(WebGPU bbox prefilter + polygon 정밀 판정). <code>{ bridgeToDraw: true }</code>를 주면 전체 버퍼 + <code>drawIndices</code> 브리지를 반환합니다.</td></tr>
                <tr><td><code>computeRoiPointGroups(pointData, regions, options)</code></td><td>TypedArray 포인트 버퍼로 ROI별 term count(<code>roiPointGroups</code>)를 계산합니다.</td></tr>
                <tr><td><code>getWebGpuCapabilities()</code></td><td>런타임에서 WebGPU 지원/어댑터/기능 정보를 조회합니다.</td></tr>
                <tr><td><code>prefilterPointsByBoundsWebGpu(positions, count, bounds)</code></td><td>ROI bounding box 기준 점 분류를 WebGPU compute로 수행합니다(실험적).</td></tr>
                <tr><td><code>calcScaleResolution(imageMpp, imageZoom, currentZoom)</code></td><td>현재 줌 기준 μm/스크린픽셀 해상도 계산.</td></tr>
                <tr><td><code>calcScaleLength(imageMpp, imageZoom, currentZoom)</code></td><td>100px 스케일바 길이를 μm/mm 문자열로 포맷.</td></tr>
                <tr><td><code>toBearerToken(token)</code></td><td>`Bearer ...` 정규화.</td></tr>
              </tbody>
            </table>
            <div class="callout">
              <strong>mpp란?</strong> <code>mpp</code>는 네이티브 피라미드 레벨(<code>maxTierZoom</code>)에서의
              <em>microns per pixel</em>(픽셀당 마이크론)입니다. 스탬프 물리 크기(mm²)는 이 값으로 환산됩니다.
              <code>mpp</code>가 없으면 <code>1μm/px</code> 가정으로 계산되어 물리 크기는 근사치가 됩니다.
            </div>
          </section>

          <p class="footer">Open Plant WSI Docs • <span data-role="year"></span></p>
        </article>
      </div>
    </main>

    <script src="../assets/site.js" defer></script>
  </body>
</html>
