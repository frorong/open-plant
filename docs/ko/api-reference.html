<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>API Reference | Open Plant WSI Docs</title>
    <meta name="description" content="Open Plant WSI API 레퍼런스" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:wght@400;500;600;700;800&family=IBM+Plex+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../assets/site.css" />
  </head>
  <body data-page="api-reference">
    <header class="topbar">
      <div class="topbar-inner">
        <a class="brand" href="index.html"><span class="brand-dot"></span><span>Open Plant WSI</span></a>
        <nav class="topnav" aria-label="Main Navigation">
          <a href="index.html" data-nav="index">개요</a>
          <a href="getting-started.html" data-nav="getting-started">빠른 시작</a>
          <a href="draw-and-roi.html" data-nav="draw-and-roi">ROI 그리기</a>
          <a href="api-reference.html" data-nav="api-reference">API</a>
          <a href="migration-guide.html" data-nav="migration-guide">마이그레이션</a>
          <a href="contributing.html" data-nav="contributing">기여 가이드</a>
          <a href="architecture.html" data-nav="architecture">아키텍처</a>
          <a href="deploy-github-pages.html" data-nav="deploy-github-pages">배포</a>
          <a href="../en/api-reference.html">EN</a>
        </nav>
      </div>
    </header>

    <main class="page">
      <div class="layout">
        <aside class="sidebar">
          <h2>API</h2>
          <a href="#wsi-viewer">WsiViewerCanvas</a>
          <a href="#draw-layer">DrawLayer</a>
          <a href="#tile-viewer">TileViewerCanvas</a>
          <a href="#wsi-types">WSI 타입</a>
          <a href="#utils">유틸 함수</a>
          <a href="#api-stability">API 안정성</a>
          <a href="migration-guide.html">마이그레이션 가이드</a>
        </aside>

        <article class="content">
          <section class="hero reveal">
            <div class="kicker">Reference</div>
            <h1>공개 API 레퍼런스</h1>
            <p>
              아래 표는 `src/index.ts`에서 export된 항목 기준입니다.
              타입/시그니처가 변경되면 이 문서도 함께 업데이트하세요.
            </p>
          </section>

          <section class="panel reveal" id="wsi-viewer">
            <h2>`WsiViewerCanvas` Props</h2>
            <table>
              <thead>
                <tr><th>이름</th><th>타입</th><th>설명</th></tr>
              </thead>
              <tbody>
                <tr><td><code>source</code></td><td><code>WsiImageSource | null</code></td><td>렌더 대상 이미지 메타데이터.</td></tr>
                <tr><td><code>authToken</code></td><td><code>string</code></td><td>필요한 요청에 Authorization 헤더 주입.</td></tr>
                <tr><td><code>viewState</code></td><td><code>Partial&lt;WsiViewState&gt;</code></td><td>외부 제어 줌/오프셋/회전(<code>rotationDeg</code>).</td></tr>
                <tr><td><code>onViewStateChange</code></td><td><code>(next) =&gt; void</code></td><td>팬/줌 변경 콜백.</td></tr>
                <tr><td><code>onStats</code></td><td><code>(stats: WsiRenderStats) =&gt; void</code></td><td>프레임 관측 이벤트. 타일/포인트 통계와 함께 queue/failure/cache hit/miss, frame 시간까지 포함합니다.</td></tr>
                <tr><td><code>onTileError</code></td><td><code>(event) =&gt; void</code></td><td>타일 로드 실패 콜백(타일 정보, 오류 객체, 재시도 횟수).</td></tr>
                <tr><td><code>onContextLost</code></td><td><code>() =&gt; void</code></td><td>WebGL 컨텍스트 손실 시 호출되며 렌더 루프가 일시 정지됩니다.</td></tr>
                <tr><td><code>onContextRestored</code></td><td><code>() =&gt; void</code></td><td>컨텍스트 복구 후 GPU 상태 재구성이 완료되면 호출됩니다.</td></tr>
                <tr><td><code>debugOverlay</code></td><td><code>boolean</code></td><td>내장 런타임 디버그 HUD를 표시합니다. 기본값 <code>false</code>.</td></tr>
                <tr><td><code>debugOverlayStyle</code></td><td><code>CSSProperties</code></td><td>내장 디버그 HUD 스타일 오버라이드.</td></tr>
                <tr><td><code>fitNonce</code></td><td><code>number</code></td><td>값이 바뀌면 `fitToImage()` 재실행.</td></tr>
                <tr><td><code>rotationResetNonce</code></td><td><code>number</code></td><td>값이 바뀌면 회전을 0도로 리셋.</td></tr>
                <tr><td><code>ctrlDragRotate</code></td><td><code>boolean</code></td><td><code>Ctrl/Cmd + drag</code> 회전 입력 허용. 기본값 <code>true</code>.</td></tr>
                <tr><td><code>pointData</code></td><td><code>WsiPointData | null</code></td><td>포인트 포지션/팔레트 인덱스 버퍼.</td></tr>
                <tr><td><code>pointPalette</code></td><td><code>Uint8Array | null</code></td><td>RGBA palette texture(1D).</td></tr>
                <tr><td><code>roiRegions</code></td><td><code>WsiRegion[]</code></td><td>영속 ROI 목록(라벨 포함).</td></tr>
                <tr><td><code>roiPolygons</code></td><td><code>DrawCoordinate[][]</code></td><td>간소화 ROI 입력.</td></tr>
                <tr><td><code>clipPointsToRois</code></td><td><code>boolean</code></td><td>ROI 외부 포인트 제거.</td></tr>
                <tr><td><code>clipMode</code></td><td><code>"sync" | "worker" | "hybrid-webgpu"</code></td><td>ROI clip 실행 모드. 기본값은 <code>"worker"</code>입니다.</td></tr>
                <tr><td><code>onClipStats</code></td><td><code>(event) =&gt; void</code></td><td>clip 실행 통계 콜백(mode, duration, input/output, WebGPU 사용 여부, draw 브리지 여부 <code>bridgedToDraw</code>).</td></tr>
                <tr><td><code>onRoiPointGroups</code></td><td><code>(stats) =&gt; void</code></td><td>현재 포인트/ROI 기준 ROI별 term count 콜백.</td></tr>
                <tr><td><code>roiPaletteIndexToTermId</code></td><td><code>ReadonlyMap&lt;number,string&gt; | string[]</code></td><td>ROI term count 산출 시 palette index를 termId로 변환하는 매핑.</td></tr>
                <tr><td><code>interactionLock</code></td><td><code>boolean</code></td><td>캔버스 pan/zoom 잠금.</td></tr>
                <tr><td><code>drawTool</code></td><td><code>"cursor" | "freehand" | "rectangle" | "circular" | "stamp-rectangle" | "stamp-circle" | "stamp-rectangle-4096px"</code></td><td>드로우 툴 모드. <code>stamp-rectangle-4096px</code>는 ROI intent가 아니라 patch intent로 완료 이벤트를 emit합니다.</td></tr>
                <tr><td><code>stampOptions</code></td><td><code>{ rectangleAreaMm2?: number; circleAreaMm2?: number; rectanglePixelSize?: number }</code></td><td>라이브러리 외부에서 스탬프 크기를 제어합니다. 면적 기반 스탬프 기본값은 2mm², 고정 픽셀 사각형은 4096px입니다.</td></tr>
                <tr><td><code>patchRegions</code></td><td><code>WsiRegion[]</code></td><td>ROI 상호작용과 분리된 patch 전용 영속 polygon 목록.</td></tr>
                <tr><td><code>patchStrokeStyle</code></td><td><code>Partial&lt;RegionStrokeStyle&gt;</code></td><td>patch 전용 stroke override(기본: cyan 점선).</td></tr>
                <tr><td><code>regionStrokeStyle</code></td><td><code>Partial&lt;RegionStrokeStyle&gt;</code></td><td>ROI stroke 스타일 override.</td></tr>
                <tr><td><code>regionStrokeHoverStyle</code></td><td><code>Partial&lt;RegionStrokeStyle&gt;</code></td><td>ROI hover 시 stroke 스타일 override.</td></tr>
                <tr><td><code>regionStrokeActiveStyle</code></td><td><code>Partial&lt;RegionStrokeStyle&gt;</code></td><td>ROI active 시 stroke 스타일 override (shadow 포함).</td></tr>
                <tr><td><code>resolveRegionStrokeStyle</code></td><td><code>(context) =&gt; Partial&lt;RegionStrokeStyle&gt;</code></td><td>region/state별 동적 stroke 스타일 resolver.</td></tr>
                <tr><td><code>overlayShapes</code></td><td><code>DrawOverlayShape[]</code></td><td>DrawLayer가 렌더링하는 커스텀 오버레이 도형(폴리곤 stroke + 반전 마스크 지원).</td></tr>
                <tr><td><code>customLayers</code></td><td><code>WsiCustomLayer[]</code></td><td>world/screen 좌표 변환기를 받는 커스텀 React 오버레이 레이어 슬롯.</td></tr>
                <tr><td><code>regionLabelStyle</code></td><td><code>Partial&lt;RegionLabelStyle&gt;</code></td><td>ROI 라벨 스타일 override.</td></tr>
                <tr><td><code>onPointerWorldMove</code></td><td><code>(event) =&gt; void</code></td><td>월드 좌표 마우스 스트림 콜백(좌표 HUD 용도).</td></tr>
                <tr><td><code>onRegionHover</code></td><td><code>(event) =&gt; void</code></td><td>cursor 모드에서 region hover 변경 이벤트.</td></tr>
                <tr><td><code>onRegionClick</code></td><td><code>(event) =&gt; void</code></td><td>cursor 모드에서 region 클릭 이벤트.</td></tr>
                <tr><td><code>onActiveRegionChange</code></td><td><code>(regionId) =&gt; void</code></td><td>active region 변경 이벤트. 기본 동작은 active 상태에서 다른 영역/다른 region 클릭 시 해제.</td></tr>
                <tr><td><code>onDrawComplete</code></td><td><code>(result) =&gt; void</code></td><td>도형 완료 결과 수신. payload에 <code>intent: "roi" | "patch"</code>가 포함됩니다.</td></tr>
                <tr><td><code>onPatchComplete</code></td><td><code>(result) =&gt; void</code></td><td><code>stamp-rectangle-4096px</code> 완료 시 patch 전용 콜백.</td></tr>
              </tbody>
            </table>
          </section>

          <section class="panel reveal" id="draw-layer">
            <h2>`DrawLayer` / 도형 유틸</h2>
            <table>
              <thead>
                <tr><th>Export</th><th>설명</th></tr>
              </thead>
              <tbody>
                <tr><td><code>DrawLayer</code></td><td>독립 오버레이 캔버스 컴포넌트.</td></tr>
                <tr><td><code>closeRing(coords)</code></td><td>첫점/끝점을 닫아 polygon ring 생성.</td></tr>
                <tr><td><code>createRectangle(start, end)</code></td><td>사각형 폐곡선 좌표 생성.</td></tr>
                <tr><td><code>createCircle(start, end)</code></td><td>원형 다각형 좌표 생성.</td></tr>
                <tr><td><code>DrawResult</code></td><td><code>{ tool, intent, coordinates, bbox, areaPx }</code> (`intent`는 <code>"roi"</code> 또는 <code>"patch"</code>)</td></tr>
                <tr><td><code>PatchDrawResult</code></td><td><code>stamp-rectangle-4096px</code> 전용 patch 결과 타입.</td></tr>
                <tr><td><code>DrawRegion</code></td><td><code>{ id?, coordinates, label? }</code></td></tr>
                <tr><td><code>DrawOverlayShape</code></td><td><code>{ id?, coordinates, closed?, fill?, stroke?, strokeStyle?, invertedFill?, visible? }</code> 형태의 오버레이 입력. <code>coordinates</code>는 <code>DrawCoordinate[]</code>, <code>DrawCoordinate[][]</code>, <code>DrawCoordinate[][][]</code>(single ring/multi-ring/multi-polygon)을 받습니다.</td></tr>
                <tr><td><code>DrawOverlayInvertedFillStyle</code></td><td><code>{ fillColor: string }</code> 폴리곤 바깥 영역을 채우는 반전 마스크 색상 스타일.</td></tr>
                <tr><td><code>RegionStyleContext</code></td><td><code>resolveRegionStrokeStyle</code>에 전달되는 상태 payload(<code>default</code>/<code>hover</code>/<code>active</code>).</td></tr>
                <tr><td><code>StampOptions</code></td><td>면적(mm²) + 고정 픽셀 사각형 옵션.</td></tr>
                <tr><td><code>RegionStrokeStyle</code></td><td>색상/두께/점선/캡/조인 + shadow(색상/블러/오프셋) 제어.</td></tr>
                <tr><td><code>RegionLabelStyle</code></td><td>폰트/배경/패딩/오프셋/라운드 제어.</td></tr>
              </tbody>
            </table>
          </section>

          <section class="panel reveal" id="tile-viewer">
            <h2>`TileViewerCanvas` Props</h2>
            <table>
              <thead>
                <tr><th>이름</th><th>타입</th><th>설명</th></tr>
              </thead>
              <tbody>
                <tr><td><code>imageWidth</code></td><td><code>number</code></td><td>원본 너비(px).</td></tr>
                <tr><td><code>imageHeight</code></td><td><code>number</code></td><td>원본 높이(px).</td></tr>
                <tr><td><code>tiles</code></td><td><code>TileDefinition[]</code></td><td>M1 타일 정의 리스트.</td></tr>
                <tr><td><code>viewState</code></td><td><code>Partial&lt;ViewState&gt;</code></td><td>초기/외부 시점 제어.</td></tr>
              </tbody>
            </table>
          </section>

          <section class="panel reveal" id="wsi-types">
            <h2>핵심 타입</h2>
            <pre><code class="language-ts">interface WsiImageSource {
  id: string;
  name: string;
  width: number;
  height: number;
  mpp?: number;
  tileSize: number;
  maxTierZoom: number;
  tilePath: string;
  tileBaseUrl: string;
  terms: WsiTerm[];
}

interface WsiPointData {
  count: number;
  positions: Float32Array; // [x0,y0,x1,y1,...]
  paletteIndices: Uint16Array;
  drawIndices?: Uint32Array; // 선택 인덱스 브리지(선택적)
}

interface WsiViewState {
  zoom: number;
  offsetX: number;
  offsetY: number;
  rotationDeg: number;
}

interface WsiRenderStats {
  tier: number;
  visible: number;
  rendered: number;
  fallback: number;
  points: number;
  cache: number;
  inflight: number;
  queued?: number;
  retries?: number;
  failed?: number;
  aborted?: number;
  cacheHits?: number;
  cacheMisses?: number;
  drawCalls?: number;
  frameMs?: number;
}</code></pre>
          </section>

          <section class="panel reveal" id="api-stability">
            <h2>API 안정성 정책 (WS-10)</h2>
            <div class="flow">
              <div class="flow-step"><strong>SemVer:</strong> patch = 버그 수정, minor = 하위호환 기능 추가, major = 브레이킹 변경.</div>
              <div class="flow-step"><strong>Deprecation 수명주기:</strong> 대체 API를 먼저 제공하고 문서에서 deprecated 표시 후 최소 두 번의 minor 릴리스 동안 호환을 유지하며, 제거는 다음 major에서만 수행합니다.</div>
              <div class="flow-step"><strong>Migration 계약:</strong> 브레이킹 변경에는 before/after 예시와 체크리스트를 반드시 동반합니다.</div>
            </div>
            <div class="callout">
              Known limitations: 실제 브라우저 상호작용(pan/zoom/draw) E2E 자동화는 아직 CI에서 완전 커버되지 않습니다.
            </div>
            <div class="callout">
              실제 업그레이드 절차와 before/after 예시는 <a href="migration-guide.html">마이그레이션 가이드</a>를 확인하세요.
            </div>
          </section>

          <section class="panel reveal" id="utils">
            <h2>유틸 함수</h2>
            <table>
              <thead>
                <tr><th>함수</th><th>설명</th></tr>
              </thead>
              <tbody>
                <tr><td><code>normalizeImageInfo(raw, tileBaseUrl)</code></td><td>백엔드 응답 + 타일 베이스 URL을 `WsiImageSource`로 변환.</td></tr>
                <tr><td><code>toTileUrl(source, tier, x, y)</code></td><td>IMS 타일 URL 생성.</td></tr>
                <tr><td><code>buildTermPalette(terms)</code></td><td>termId → palette index 매핑 + RGBA 팔레트 생성.</td></tr>
                <tr><td><code>filterPointDataByPolygons(data, polygons)</code></td><td>ROI 다각형 기반 포인트 필터링.</td></tr>
                <tr><td><code>filterPointDataByPolygonsInWorker(data, polygons)</code></td><td>ROI 필터를 워커 스레드에서 실행합니다.</td></tr>
                <tr><td><code>filterPointIndicesByPolygons(data, polygons)</code></td><td>polygon 내부 원본 point 인덱스를 반환해 patch JSON export 파이프라인을 구성합니다.</td></tr>
                <tr><td><code>filterPointIndicesByPolygonsInWorker(data, polygons)</code></td><td>point 인덱스 반환의 워커 버전(+duration 메타).</td></tr>
                <tr><td><code>filterPointDataByPolygonsHybrid(data, polygons, options?)</code></td><td>실험적 하이브리드 경로(WebGPU bbox prefilter + polygon 정밀 판정). <code>{ bridgeToDraw: true }</code>를 주면 전체 버퍼 + <code>drawIndices</code> 브리지를 반환합니다.</td></tr>
                <tr><td><code>computeRoiPointGroups(pointData, regions, options)</code></td><td>TypedArray 포인트 버퍼로 ROI별 term count(<code>roiPointGroups</code>)를 계산합니다.</td></tr>
                <tr><td><code>getWebGpuCapabilities()</code></td><td>런타임에서 WebGPU 지원/어댑터/기능 정보를 조회합니다.</td></tr>
                <tr><td><code>prefilterPointsByBoundsWebGpu(positions, count, bounds)</code></td><td>ROI bounding box 기준 점 분류를 WebGPU compute로 수행합니다(실험적).</td></tr>
                <tr><td><code>calcScaleResolution(imageMpp, imageZoom, currentZoom)</code></td><td>현재 줌 기준 μm/스크린픽셀 해상도 계산.</td></tr>
                <tr><td><code>calcScaleLength(imageMpp, imageZoom, currentZoom)</code></td><td>100px 스케일바 길이를 μm/mm 문자열로 포맷.</td></tr>
                <tr><td><code>toBearerToken(token)</code></td><td>`Bearer ...` 정규화.</td></tr>
              </tbody>
            </table>
            <div class="callout">
              <strong>mpp란?</strong> <code>mpp</code>는 네이티브 피라미드 레벨(<code>maxTierZoom</code>)에서의
              <em>microns per pixel</em>(픽셀당 마이크론)입니다. 스탬프 물리 크기(mm²)는 이 값으로 환산됩니다.
              <code>mpp</code>가 없으면 <code>1μm/px</code> 가정으로 계산되어 물리 크기는 근사치가 됩니다.
            </div>
          </section>

          <p class="footer">Open Plant WSI Docs • <span data-role="year"></span></p>
        </article>
      </div>
    </main>

    <script src="../assets/site.js" defer></script>
  </body>
</html>
