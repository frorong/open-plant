<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Architecture | Open Plant WSI Docs</title>
    <meta name="description" content="Open Plant WSI 렌더링 아키텍처" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:wght@400;500;600;700;800&family=IBM+Plex+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../assets/site.css" />
  </head>
  <body data-page="architecture">
    <header class="topbar">
      <div class="topbar-inner">
        <a class="brand" href="index.html"><span class="brand-dot"></span><span>Open Plant WSI</span></a>
        <nav class="topnav" aria-label="Main Navigation">
          <a href="index.html" data-nav="index">개요</a>
          <a href="getting-started.html" data-nav="getting-started">빠른 시작</a>
          <a href="draw-and-roi.html" data-nav="draw-and-roi">ROI 그리기</a>
          <a href="api-reference.html" data-nav="api-reference">API</a>
          <a href="migration-guide.html" data-nav="migration-guide">마이그레이션</a>
          <a href="contributing.html" data-nav="contributing">기여 가이드</a>
          <a href="architecture.html" data-nav="architecture">아키텍처</a>
          <a href="deploy-github-pages.html" data-nav="deploy-github-pages">배포</a>
          <a href="../en/architecture.html">EN</a>
        </nav>
      </div>
    </header>

    <main class="page">
      <div class="layout">
        <aside class="sidebar">
          <h2>아키텍처</h2>
          <a href="#runtime">런타임 구성</a>
          <a href="#tile-pipeline">타일 파이프라인</a>
          <a href="#recovery">안정성/복구</a>
          <a href="#point-pipeline">포인트 파이프라인</a>
          <a href="#roi-accel">ROI 가속 모드</a>
          <a href="#draw-pipeline">드로잉 파이프라인</a>
          <a href="#webgpu">WebGPU 확장 방향</a>
          <a href="#oss-docs">오픈소스 문서 원칙</a>
        </aside>

        <article class="content">
          <section class="hero reveal">
            <div class="kicker">Engine</div>
            <h1>단일 캔버스 렌더 루프 + 오버레이 드로잉</h1>
            <p>
              타일/포인트는 WebGL2에서 합성하고, ROI 인터랙션은 독립 Overlay
              Canvas에서 처리합니다. 성능과 UX를 분리해 안정적으로 유지하는 구조입니다.
            </p>
          </section>

          <section class="panel reveal" id="runtime">
            <h2>런타임 구성</h2>
            <pre><code class="language-txt">React
 └─ WsiViewerCanvas
    ├─ WebGL Canvas (WsiTileRenderer: pan/zoom/rotate)
    │  ├─ Tile pass (bitmap quads)
    │  └─ Point pass (palette indexed ring points)
    └─ DrawLayer Canvas (pointer capture, ROI preview/labels)</code></pre>
          </section>

          <section class="panel reveal" id="tile-pipeline">
            <h2>타일 파이프라인</h2>
            <div class="flow">
              <div class="flow-step"><strong>tier 선택:</strong> `rawTier = maxTierZoom + log2(zoom)`.</div>
              <div class="flow-step"><strong>visible tile 계산:</strong> viewport와 tile grid 교차 범위를 계산.</div>
              <div class="flow-step"><strong>캐시 우선 렌더:</strong> 기존 캐시 타일(특히 이전 tier) 먼저 draw.</div>
              <div class="flow-step"><strong>타일 전용 색상 보정:</strong> brightness/contrast/saturation uniform은 tile fragment shader에만 적용됩니다.</div>
              <div class="flow-step"><strong>신규 타일 비동기 요청:</strong> 요청 완료 시 texture 업로드 후 다음 frame에서 반영.</div>
              <div class="flow-step"><strong>LRU trim:</strong> `maxCacheTiles` 초과 시 오래된 texture 정리.</div>
            </div>
            <div class="callout">
              fallback 타일을 먼저 렌더하기 때문에 줌 변경 직후 검은 화면이 아닌 점진적 채움이 유지됩니다.
            </div>
          </section>

          <section class="panel reveal" id="recovery">
            <h2>안정성/복구 (WS-7)</h2>
            <div class="flow">
              <div class="flow-step"><strong>컨텍스트 손실 대응:</strong> <code>webglcontextlost</code>에서 프레임 루프/드래그/타일 스케줄러를 즉시 정지합니다.</div>
              <div class="flow-step"><strong>복구 재초기화:</strong> <code>webglcontextrestored</code> 시 셰이더/버퍼/텍스처를 재생성합니다.</div>
              <div class="flow-step"><strong>포인트 자동 복원:</strong> 마지막 point buffer/palette를 CPU 스냅샷에서 자동 재업로드합니다.</div>
              <div class="flow-step"><strong>네트워크 degrade:</strong> retry/backoff + fallback tier 렌더로 타일 실패 중에도 화면 연속성을 유지합니다.</div>
              <div class="flow-step"><strong>호스트 콜백:</strong> <code>onContextLost</code>, <code>onContextRestored</code>, <code>onTileError</code>로 장애 신호를 외부 앱에 전달합니다.</div>
            </div>
          </section>

          <section class="panel reveal" id="point-pipeline">
            <h2>포인트 파이프라인</h2>
            <div class="flow">
              <div class="flow-step"><strong>외부 파싱:</strong> 포인트 로딩/디코딩(zstd+MVT 등)은 호출자 책임.</div>
              <div class="flow-step"><strong>입력 계약:</strong> <code>Float32Array</code> positions + <code>Uint16Array</code> paletteIndices를 기본으로 받고, 선택적으로 <code>fillModes</code>/<code>drawIndices</code>를 수신합니다.</div>
              <div class="flow-step"><strong>업로드:</strong> positions/paletteIndices를 GPU 버퍼로 전송.</div>
              <div class="flow-step"><strong>셰이더 렌더:</strong> <code>fillModes</code> 기반 ring/solid 모드로 palette 색상을 렌더합니다.</div>
              <div class="flow-step"><strong>ROI clip:</strong> 필요 시 <code>clipMode</code>에 따라 polygon 내부 포인트만 필터링.</div>
              <div class="flow-step"><strong>ROI 통계:</strong> <code>computeRoiPointGroups</code> / <code>onRoiPointGroups</code>로 ROI별 term 집계.</div>
            </div>
          </section>

          <section class="panel reveal" id="roi-accel">
            <h2>ROI 가속 모드</h2>
            <div class="card-grid">
              <div class="card">
                <h3>`sync`</h3>
                <p>메인 스레드에서 즉시 polygon 필터링. 디버깅/기준 측정용.</p>
              </div>
              <div class="card">
                <h3>`worker`</h3>
                <p>전용 worker 스레드에서 ROI 필터링. UI 프리즈를 줄이는 현재 권장 기본값.</p>
              </div>
              <div class="card">
                <h3>`hybrid-webgpu`</h3>
                <p>실험 경로. WebGPU bbox prefilter + polygon 정밀 판정 후 <code>drawIndices</code> 브리지로 인덱스 기반 포인트 렌더를 수행합니다.</p>
              </div>
              <div class="card">
                <h3>관측</h3>
                <p><code>onStats</code>/<code>onClipStats</code>와 내장 <code>debugOverlay</code>로 런타임 지표를 수집하고 회귀를 빠르게 추적합니다.</p>
              </div>
            </div>
          </section>

          <section class="panel reveal" id="draw-pipeline">
            <h2>드로잉 파이프라인</h2>
            <div class="flow">
              <div class="flow-step"><strong>카메라 입력:</strong> pan + wheel zoom + <code>Ctrl/Cmd + drag</code> 회전(<code>rotationDeg</code>).</div>
              <div class="flow-step"><strong>Pointer capture:</strong> draw 활성 시 입력을 DrawLayer가 독점.</div>
              <div class="flow-step"><strong>미리보기:</strong> freehand/rectangle/circular preview 또는 brush cursor+stroke.</div>
              <div class="flow-step"><strong>완료:</strong> tool별 좌표를 닫힌 ring으로 변환 후 `onDrawComplete` emit(<code>intent: "roi" | "patch" | "brush"</code>).</div>
              <div class="flow-step"><strong>Region 상호작용:</strong> cursor 모드 hit-test 대상은 contour + 라벨 영역이며 내부 fill은 제외됩니다.</div>
              <div class="flow-step"><strong>영속 표시:</strong> `persistedRegions`로 outline와 label을 계속 렌더.</div>
            </div>
          </section>

          <section class="panel reveal" id="webgpu">
            <h2>WebGPU 확장 방향 (연산 전용)</h2>
            <div class="card-grid">
              <div class="card">
                <h3>ROI Culling</h3>
                <p>bbox prefilter compute를 시작점으로 polygon 정밀 판정을 결합합니다.</p>
              </div>
              <div class="card">
                <h3>LOD Aggregation</h3>
                <p>저배율에서 cell density 집계를 compute pass로 사전 생성.</p>
              </div>
              <div class="card">
                <h3>Term Histogram</h3>
                <p>ROI 단위 term count/positivity 통계를 GPU에서 병렬 계산.</p>
              </div>
              <div class="card">
                <h3>Interop</h3>
                <p>연산 결과를 WebGL 업로드 가능한 packed buffer로 반환.</p>
              </div>
            </div>
            <div class="callout">
              현재 WebGPU 경로는 <strong>실험적</strong>입니다. 실데이터 벤치마크가 확인되기 전까지는
              운영 기본값을 <code>worker</code>로 유지하는 것을 권장합니다.
            </div>
          </section>

          <section class="panel reveal" id="oss-docs">
            <h2>오픈소스 문서 원칙</h2>
            <div class="flow">
              <div class="flow-step"><strong>동작 우선:</strong> 각 모드의 기본값/폴백/실패 동작을 명시합니다.</div>
              <div class="flow-step"><strong>버전 동기화:</strong> 문서와 <code>src/index.ts</code> export 변경을 같은 PR에서 처리합니다.</div>
              <div class="flow-step"><strong>측정 근거:</strong> 성능 주장은 <code>onStats</code>/<code>onClipStats</code> 수치로 재현 가능해야 합니다.</div>
              <div class="flow-step"><strong>이중언어 동등성:</strong> EN/KO 문서는 기능 단위로 동일 정보를 유지합니다.</div>
            </div>
          </section>

          <p class="footer">Open Plant WSI Docs • <span data-role="year"></span></p>
        </article>
      </div>
    </main>

    <script src="../assets/site.js" defer></script>
  </body>
</html>
