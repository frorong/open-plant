<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ROI Draw | Open Plant WSI Docs</title>
    <meta name="description" content="freehand/rectangle/circular + stamp ROI 드로잉 가이드" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:wght@400;500;600;700;800&family=IBM+Plex+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../assets/site.css" />
  </head>
  <body data-page="draw-and-roi">
    <header class="topbar">
      <div class="topbar-inner">
        <a class="brand" href="index.html"><span class="brand-dot"></span><span>Open Plant WSI</span></a>
        <nav class="topnav" aria-label="Main Navigation">
          <a href="index.html" data-nav="index">개요</a>
          <a href="getting-started.html" data-nav="getting-started">빠른 시작</a>
          <a href="draw-and-roi.html" data-nav="draw-and-roi">ROI 그리기</a>
          <a href="api-reference.html" data-nav="api-reference">API</a>
          <a href="migration-guide.html" data-nav="migration-guide">마이그레이션</a>
          <a href="contributing.html" data-nav="contributing">기여 가이드</a>
          <a href="architecture.html" data-nav="architecture">아키텍처</a>
          <a href="deploy-github-pages.html" data-nav="deploy-github-pages">배포</a>
          <a href="../en/draw-and-roi.html">EN</a>
        </nav>
      </div>
    </header>

    <main class="page">
      <div class="layout">
        <aside class="sidebar">
          <h2>ROI 그리기</h2>
          <a href="#toolbar">툴바 상태 모델</a>
          <a href="#draw-complete">결과 수신</a>
          <a href="#brush-ux">Brush UX</a>
          <a href="#stamp-size">Stamp 크기</a>
          <a href="#persist">영역 유지/라벨</a>
          <a href="#style">스타일 커스터마이징</a>
          <a href="#clip">ROI 기반 포인트 필터</a>
          <a href="#roi-stats">ROI term 통계</a>
        </aside>

        <article class="content">
          <section class="hero reveal">
            <div class="kicker">Interactive Region</div>
            <h1>Draw + Stamp ROI 툴</h1>
            <p>
              `drawTool`이 `cursor`가 아닌 동안 `DrawLayer`가 활성화되어
              pan/zoom과 충돌 없이 ROI를 생성합니다. 결과는 닫힌 polygon 좌표로
              반환됩니다. brush도 완료 시점에 <code>intent: "brush"</code> payload를 반환합니다.
              stamp 툴은 클릭 한 번으로 물리 크기 ROI(2mm² 사각형/원, 0.2mm² HPF 원)를
              생성합니다. 고정 픽셀 사각형(<code>stamp-rectangle-4096px</code>)은
              patch intent로 완료되며 <code>onPatchComplete</code>에서 별도 처리할 수 있습니다.
            </p>
          </section>

          <section class="panel reveal" id="toolbar">
            <h2>1. 툴바와 draw 상태</h2>
            <pre><code class="language-tsx">import { useState } from "react";
import { WsiViewerCanvas } from "open-plant";

const [drawTool, setDrawTool] = useState("cursor");

&lt;div className="toolbar"&gt;
  &lt;button onClick={() =&gt; setDrawTool("freehand")}&gt;Freehand&lt;/button&gt;
  &lt;button onClick={() =&gt; setDrawTool("rectangle")}&gt;Rectangle&lt;/button&gt;
  &lt;button onClick={() =&gt; setDrawTool("circular")}&gt;Circular&lt;/button&gt;
  &lt;button onClick={() =&gt; setDrawTool("stamp-rectangle")}&gt;Stamp □&lt;/button&gt;
  &lt;button onClick={() =&gt; setDrawTool("stamp-circle")}&gt;Stamp ○&lt;/button&gt;
  &lt;button onClick={() =&gt; setDrawTool("stamp-rectangle-4096px")}&gt;Stamp 4096px&lt;/button&gt;
  &lt;button onClick={() =&gt; setCircleAreaMm2(0.2)}&gt;HPF 0.2mm²&lt;/button&gt;
  &lt;button onClick={() =&gt; setDrawTool("cursor")}&gt;Cursor&lt;/button&gt;
&lt;/div&gt;

&lt;WsiViewerCanvas
  source={source}
  drawTool={drawTool}
  interactionLock={drawTool !== "cursor"}
/&gt;</code></pre>
          </section>

          <section class="panel reveal" id="draw-complete">
            <h2>2. Draw 완료 결과</h2>
            <pre><code class="language-tsx">const onDrawComplete = (result) =&gt; {
  console.log(result.tool); // freehand | rectangle | circular | brush | stamp-...
  console.log(result.intent); // "roi" | "patch" | "brush"
  console.log(result.coordinates); // closed ring
  console.log(result.bbox); // [minX, minY, maxX, maxY]
  console.log(result.areaPx); // polygon area
};

const onPatchComplete = (patch) =&gt; {
  // patch.tool === "stamp-rectangle-4096px"
  setPatchRegions((prev) =&gt; [...prev, { id: Date.now(), coordinates: patch.coordinates }]);
};

&lt;WsiViewerCanvas
  source={source}
  drawTool={drawTool}
  onDrawComplete={onDrawComplete}
  onPatchComplete={onPatchComplete}
/&gt;</code></pre>
            <div class="callout">
              드로잉 중 ESC를 누르면 현재 세션이 취소됩니다. stamp 툴은 클릭 즉시 완료됩니다.
            </div>
          </section>

          <section class="panel reveal" id="brush-ux">
            <h2>3. Brush UX (화면 고정 반경 + 탭 선택)</h2>
            <pre><code class="language-tsx">&lt;WsiViewerCanvas
  source={source}
  drawTool="brush"
  brushOptions={{
    radius: 24,           // HTML/CSS px 기준 (화면에서 줌 불변)
    edgeDetail: 1.5,
    edgeSmoothing: 2,
    clickSelectRoi: true, // brush 모드 탭 시 ROI를 먼저 선택
  }}
  onDrawComplete={(result) =&gt; {
    // brush 완료 -> result.intent === "brush"
  }}
  onRegionClick={(event) =&gt; {
    // clickSelectRoi=true + ROI contour/label 탭 시 이벤트
  }}
/&gt;</code></pre>
            <p>
              <code>clickSelectRoi=true</code>이면 brush 탭에서 ROI 선택/토글을 우선 수행합니다.
              ROI 외부 탭은 일반 brush stroke로 처리됩니다.
            </p>
          </section>

          <section class="panel reveal" id="stamp-size">
            <h2>4. Stamp 크기 prop 제어</h2>
            <pre><code class="language-tsx">const [rectAreaMm2, setRectAreaMm2] = useState(2);
const [circleAreaMm2, setCircleAreaMm2] = useState(2);
const [rectPixelSize, setRectPixelSize] = useState(4096);

&lt;WsiViewerCanvas
  source={source}
  drawTool={drawTool}
  stampOptions={{
    rectangleAreaMm2: rectAreaMm2,
    circleAreaMm2: circleAreaMm2,
    rectanglePixelSize: rectPixelSize,
  }}
/&gt;</code></pre>
            <p>
              <code>mpp</code>는 네이티브 레벨(<code>maxTierZoom</code>)에서의 픽셀당 마이크론(μm/px)입니다.
              stamp 면적(mm²)은 <code>mpp</code>와 현재 줌으로 환산되어 줌이 바뀌어도 물리 크기가 유지됩니다.
            </p>
          </section>

          <section class="panel reveal" id="persist">
            <h2>5. ROI 영속화와 라벨 표시</h2>
            <pre><code class="language-tsx">const [regions, setRegions] = useState([]);
const [labelInput, setLabelInput] = useState("ROI");

const handleDrawComplete = (result) =&gt; {
  setRegions((prev) =&gt; [
    ...prev,
    {
      id: `${Date.now()}`,
      label: labelInput,
      coordinates: result.coordinates,
    },
  ]);
  setDrawTool("cursor");
};

&lt;WsiViewerCanvas
  source={source}
  drawTool={drawTool}
  roiRegions={regions}
  patchRegions={patches}
  patchStrokeStyle={{ color: "#8ad8ff", width: 2, lineDash: [10, 8] }}
  onDrawComplete={handleDrawComplete}
/&gt;</code></pre>
            <p>
              라벨은 각 region의 최상단(anchor) 기준으로 마지막에 그려지므로,
              윤곽선/채움 위에 항상 보입니다.
            </p>
          </section>

          <section class="panel reveal" id="style">
            <h2>6. 인터랙션/스타일 외부 제어</h2>
            <pre><code class="language-tsx">&lt;WsiViewerCanvas
  source={source}
  roiRegions={regions}
  activeRegionId={selectedRoiId} // controlled 모드
  onActiveRegionChange={setSelectedRoiId}
  drawFillColor="transparent"
  patchRegions={patches}
  patchStrokeStyle={{ color: "#8ad8ff", width: 2, lineDash: [10, 8] }}
  regionStrokeStyle={{
    color: "#ffd166",
    width: 2.5,
  }}
  regionStrokeHoverStyle={{
    color: "#ff2f2f",
    width: 3,
  }}
  regionStrokeActiveStyle={{
    color: "#ff2f2f",
    width: 3,
    shadowColor: "rgba(255, 47, 47, 0.95)",
    shadowBlur: 12,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
  }}
  resolveRegionStrokeStyle={(ctx) =&gt; {
    if (ctx.state === "hover") return { color: "#ff2f2f", width: 3 };
    if (ctx.state === "active") return { color: "#ff2f2f", width: 3.2, shadowBlur: 12 };
  }}
  resolveRegionLabelStyle={({ zoom }) =&gt; ({
    offsetY: zoom &gt; 4 ? -20 : -10,
  })}
  autoLiftRegionLabelAtMaxZoom
  drawAreaTooltip={{
    enabled: true,
    format: (areaMm2) =&gt; `${areaMm2.toFixed(3)} mm²`,
    cursorOffset: { x: 16, y: -24 },
  }}
  overlayShapes={[
    {
      id: "weak-positive-area",
      coordinates: [
        [[1000,1000],[3000,1000],[3000,3000],[1000,3000]],
        [[3400,1200],[4300,1200],[4300,2300],[3400,2300]],
      ],
      closed: true,
      stroke: { color: "#CB59FF", width: 3, lineDash: [5, 5] },
      invertedFill: { fillColor: "rgba(0, 0, 0, 0.15)" },
      visible: true,
    },
  ]}
  onPointerWorldMove={(event) =&gt; {
    // event.coordinate -> [x, y] | null
  }}
  regionLabelStyle={{
    fontFamily: "IBM Plex Mono, monospace",
    fontSize: 12,
    textColor: "#fff4cc",
    backgroundColor: "rgba(8, 14, 22, 0.9)",
    borderColor: "#ffd166",
    borderWidth: 1,
    paddingX: 8,
    paddingY: 4,
    offsetY: 12,
    borderRadius: 4,
  }}
  onRegionHover={(event) =&gt; {
    // event.regionId, event.regionIndex, event.coordinate
  }}
  onRegionClick={(event) =&gt; {
    // event.regionId, event.region, event.coordinate
  }}
  onPatchComplete={(patch) =&gt; {
    // patch 전용 완료 이벤트
  }}
  customLayers={[
    {
      id: "patch-label-layer",
      render: ({ worldToScreen }) =&gt; {
        // host가 직접 제어하는 React 오버레이
      },
    },
  ]}
/&gt;</code></pre>
            <p>
              cursor 모드 region hit-test는 contour + 라벨 영역만 대상으로 하며 내부 fill은 제외됩니다.
              <code>activeRegionId</code>를 생략하면 기존처럼 uncontrolled active 상태로 동작합니다.
            </p>
          </section>

          <section class="panel reveal" id="clip">
            <h2>7. Draw 영역에만 셀 렌더</h2>
            <pre><code class="language-tsx">&lt;WsiViewerCanvas
  source={source}
  pointData={pointData}
  pointPalette={pointPalette}
  roiRegions={regions}
  clipPointsToRois
  clipMode="worker"
  onClipStats={(stats) =&gt; {
    console.log(stats.mode, stats.durationMs, stats.outputCount);
  }}
/&gt;</code></pre>
            <p>
              `clipPointsToRois`를 켜면 포인트 버퍼가 ROI polygon 내부 포인트만 남도록
              필터링되어 렌더됩니다.
            </p>
            <p>
              <code>clipMode</code>는 ROI 필터 실행 경로를 선택합니다:
              <code>sync</code>(메인 스레드), <code>worker</code>(권장), <code>hybrid-webgpu</code>(실험적).
            </p>
          </section>

          <section class="panel reveal" id="roi-stats">
            <h2>8. ROI term count 통계 API</h2>
            <pre><code class="language-tsx">import { computeRoiPointGroups } from "open-plant";

const stats = computeRoiPointGroups(pointData, regions, {
  paletteIndexToTermId: ["bg", "negative", "positive"],
});

&lt;WsiViewerCanvas
  source={source}
  pointData={pointData}
  roiRegions={regions}
  onRoiPointGroups={(result) =&gt; {
    // result.groups -> [{ regionId, totalCount, termCounts[] }]
  }}
/&gt;</code></pre>
          </section>

          <p class="footer">Open Plant WSI Docs • <span data-role="year"></span></p>
        </article>
      </div>
    </main>

    <script src="../assets/site.js" defer></script>
  </body>
</html>
